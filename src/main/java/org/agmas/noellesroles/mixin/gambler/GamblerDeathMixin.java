package org.agmas.noellesroles.mixin.gambler;

import dev.doctor4t.trainmurdermystery.api.Role;
import dev.doctor4t.trainmurdermystery.api.TMMRoles;
import dev.doctor4t.trainmurdermystery.cca.GameRoundEndComponent;
import dev.doctor4t.trainmurdermystery.cca.GameWorldComponent;
import dev.doctor4t.trainmurdermystery.client.gui.RoleAnnouncementTexts;
import dev.doctor4t.trainmurdermystery.game.GameFunctions;
import dev.doctor4t.trainmurdermystery.util.AnnounceWelcomePayload;
import net.fabricmc.fabric.api.networking.v1.ServerPlayNetworking;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.SoundEvents;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import org.agmas.harpymodloader.Harpymodloader;
import org.agmas.harpymodloader.config.HarpyModLoaderConfig;
import org.agmas.harpymodloader.events.ModdedRoleAssigned;
import org.agmas.noellesroles.NRSounds;
import org.agmas.noellesroles.Noellesroles;
import org.agmas.noellesroles.gambler.GamblerPlayerComponent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static dev.doctor4t.trainmurdermystery.game.GameFunctions.getSpawnPos;
import static dev.doctor4t.trainmurdermystery.game.GameFunctions.roomToPlayer;
import static org.agmas.noellesroles.Noellesroles.EXECUTIONER_ID;

@Mixin(GameFunctions.class)
public class GamblerDeathMixin {

	@Inject(method = "killPlayer(Lnet/minecraft/entity/player/PlayerEntity;ZLnet/minecraft/entity/player/PlayerEntity;Lnet/minecraft/util/Identifier;)V", at = @At("HEAD"), cancellable = true)
	private static void onGamblerDeath(PlayerEntity victim, boolean spawnBody, PlayerEntity killer, Identifier identifier, CallbackInfo ci) {
		final var world = victim.getWorld();
		GameWorldComponent gameWorldComponent = GameWorldComponent.KEY.get(world);
		
		if (gameWorldComponent.isRole(victim, Noellesroles.GAMBLER)) {
			GamblerPlayerComponent gamblerPlayerComponent = GamblerPlayerComponent.KEY.get(victim);

			// 如果已经使用过能力，则正常死亡
			if (gamblerPlayerComponent.usedAbility) {
				return;
			}
			
			// 获取随机数决定结果 (0-99)
			int chance = victim.getRandom().nextInt(100);
			
			// 33%概率直接死亡 (0-32)
			if (chance < 33) {
				// 直接死亡，不取消事件
				return;
			}
			// 33%概率变为警长 (33-65)
			else if (chance < 66) {
				// 标记已使用能力
				gamblerPlayerComponent.usedAbility = true;
				gamblerPlayerComponent.sync();
				
				// 变成正义阵营（vigilante）

				gameWorldComponent.addRole(victim, TMMRoles.VIGILANTE);
				ModdedRoleAssigned.EVENT.invoker().assignModdedRole(victim,TMMRoles.VIGILANTE);
				if (Harpymodloader.VANNILA_ROLES.contains(gameWorldComponent.getRole(victim))) {
					ServerPlayNetworking.send((ServerPlayerEntity) victim, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(TMMRoles.VIGILANTE), gameWorldComponent.getAllKillerTeamPlayers().size(), 0));
				} else {
					ServerPlayNetworking.send((ServerPlayerEntity) victim, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(Harpymodloader.autogeneratedAnnouncements.get(gameWorldComponent.getRole(victim))), gameWorldComponent.getAllKillerTeamPlayers().size(), 0));
				}
				teleport( victim);
				// 取消死亡，玩家会在自己的房间复活
				ci.cancel();
			}
			// 33%概率变成杀手 (66-98)
			else if (chance < 99) {
				// 标记已使用能力
				gamblerPlayerComponent.usedAbility = true;
				gamblerPlayerComponent.sync();
				
				// 变成杀手阵营
				ArrayList<Role> shuffledKillerRoles = new ArrayList<>(TMMRoles.ROLES);
				shuffledKillerRoles.removeIf(role ->role.identifier().equals(EXECUTIONER_ID) || Harpymodloader.VANNILA_ROLES.contains(role) || !role.canUseKiller() || HarpyModLoaderConfig.HANDLER.instance().disabled.contains(role.identifier().getPath()));
				if (shuffledKillerRoles.isEmpty()) shuffledKillerRoles.add(TMMRoles.KILLER);
				Collections.shuffle(shuffledKillerRoles);
				
				gameWorldComponent.addRole(victim, shuffledKillerRoles.getFirst());
				ModdedRoleAssigned.EVENT.invoker().assignModdedRole(victim,TMMRoles.VIGILANTE);
				if (Harpymodloader.VANNILA_ROLES.contains(gameWorldComponent.getRole(victim))) {
					ServerPlayNetworking.send((ServerPlayerEntity) victim, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(TMMRoles.KILLER), gameWorldComponent.getAllKillerTeamPlayers().size(), 0));
				} else {
					ServerPlayNetworking.send((ServerPlayerEntity) victim, new AnnounceWelcomePayload(RoleAnnouncementTexts.ROLE_ANNOUNCEMENT_TEXTS.indexOf(Harpymodloader.autogeneratedAnnouncements.get(gameWorldComponent.getRole(victim))), gameWorldComponent.getAllKillerTeamPlayers().size(), 0));
				}
				// 取消死亡，玩家会在自己的房间复活
				teleport( victim);
				ci.cancel();
			}
			// 1%保留给用户自定义 (99)
			else {

				if (world instanceof ServerWorld serverWorld) {
					final var players = serverWorld.getPlayers();
					players.forEach(
							player -> {
								player.playSound(SoundEvents.ENTITY_GENERIC_EXPLODE.value(), 1.2F, 1.4F);
							}
					);
					GameRoundEndComponent.KEY.get(serverWorld).setRoundEndData(players, GameFunctions.WinStatus.GAMBLER);

					GameFunctions.stopGame(serverWorld);
				}
				return;
			}
			world.getPlayers().forEach(
					player -> {
						player.playSound(NRSounds.GAMBER_DEATH, 0.5F, 1.3F);
					}
			);
		}
	}
	private static void teleport(PlayerEntity player){

		Vec3d pos = getSpawnPos(roomToPlayer.getOrDefault(player.getUuid(), 1));
		if (pos != null) {
			player.requestTeleport(pos.getX(), pos.getY() + 1, pos.getZ());
		}

	}
}